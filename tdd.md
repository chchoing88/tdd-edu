# 테스트 주도 개발의 패턴

## 테스트 주도 개발 패턴

### 테스트

작성한 소프트웨어를 어떻게 테스트할 것인가? 자동화된 테스트를 만들어라.
테스트하다(test)는 '평가하다' 라는 뜻의 동사이다.
명사로서의 테스트 (자동으로 실행되는 과정)
동사로서의 테스트 (버튼을 몇 개 눌러보고 화면에 나오는 결과를 주시하는 과정)

스트레스가 많아지면 테스트가 뜸해지고 그러다 보면 에러는 점점 많아진다. 에러가 많아지면 더 많은 스트레스를 받게 될 것이다. 어떻게 하면 이런 고리를 끊어 낼 수 있을까?

이 경우에는 '테스트'를 '자동화된 테스트'로 치환하면 된다.

스트레스를 더 많이 받을수록 테스트도 더 많이 실행한다. 테스트를 실행하면 즉시 좋은 느낌을 받게 되고 그러면 작업 중에 에러를 낼 일도 줄게 되며 스트레스도 적어진다.

자동화된 테스트가 있다면 두려운 정도를 선택할 수 있다.

> 트랜잭션 메커니즘이란 결국 트랜잭션이 커밋되기 전까지 변수가 진짜로 변하면 안 된다는 것에 있다.

### 격리된 테스트

테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가? 아무 영향이 없어야 한다.

1. 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자는 것.
2. 어마어마한 실패 케이스가 반드시 어마어마한 양의 문제를 의미하는 것은 아니라는 점. 앞 부분에서 실행된 테스트가 실패한 후 그 영향으로 다음 테스트부터는 시스템이 예측 불가능한 상태에 놓이는 경우가 많다.
3. 테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다는 것.
4. 각각의 테스트는 다른 테스트와 완전히 독립적이어야 한다는 것.

격리된 테스트가 내포하는 것

- 주어진 문제를 작은 단위로 분리하기 위해 노력해서 각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다는 것이다.
- 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.

결합도(coupling)?

소프트웨어 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 또한 얼마나 의존적인지 나타내는 정도

결합도가 높은 클래스의 문제점

- 연관된 다른 클래스가 변경되면 더불어 변경해야 한다.
- 수정하려는 클래스를 이해하기 위해 연관된 다른 클래스를 함께 이해해야 한다.
- 나중에 다른 프로그램에서 클래스를 재사용하기도 힘들다.

응집도(cohension)?

프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 연관된 기능들이 모여있고 지나치게 많은 일을 하지 않으면 응집도가 높다고 표현한다.

응집도가 낮은 클래스의 문제점

- 이해하기 힘들다.
- 따로 재사용하기 힘들다.
- 유지보수하기 힘들다.
- 다른 클래스의 변화에 민감하다.

### 테스트 목록

- 시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것.
- 구현해야 할 것들에 대한 테스트를 목록에 적는다.
- 우선 구현할 필요가 있는 모든 오퍼레이션의 사용 예들을 적는다.
- 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전(아무 일도 하지 않는 버전)을 리스트에 적습니다.
- 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 적습니다.

테스트를 통과하게 만드는 과정에서 작성한 코드들은 새로운 테스트가 필요함을 암시적으로 알려준다.

### 테스트 우선

테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.
테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다.

테스트는 프로그램 설계와 작업 범위 조절에 유용하다.

### 단언 우선

단언을 제일 먼저 쓰고 시작하라. 자기 유사성(self-similarity)이란 참 멋지다.

- 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다.
- 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.
- 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다.
구현에 대해 전혀 고려하지 않고 테스트만 작성할 떄도 사실 몇 가지 문제들을 한번에 해결하는 것이다.

"올바른 결과는 무엇인가?" , "어던 식으로 검사할 것인가?" 는 여러 문제에서 쉽게 분리할 수 있다.

### 테스트 데이터

테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라.

테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다.
테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다.

### 명백한 데이터

테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.
단언 부분에 일단 수식을 써놓으면 다음으로 무엇을 해야 할지 쉽게 알게 된다.

이 오퍼레이션이 어디에 속할지를 점진적으로 알아내기 위해 가짜 구현을 해볼 수도 있다.

## 빨간 막대 패턴

이 패턴들은 테스트를 언제 어디에 작성할 것인지, 테스트 작성을 언제 멈출지에 대한 것이다.

### 한 단계 테스트

목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가? 나에게 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것.

만약 메타포가 어떤 방향성을 가질 필요가 있다면 '아는 것에서 모르는 것으로' 라는 방향이 유용할 것이다.
'아는 것에서 모르는 것으로'는 우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발 하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.

### 시작 테스트

어떤 테스트부터 시작하는 게 좋을까? 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트 할 것.

첫 걸음으로 현실적인 테스트를 하나 작성한다면 상당히 많은 문제를 한번에 해결해야 하는 상황이 될 것이다.

- 이 오퍼레이션을 어디에 두어야 하나?
- 적절한 입력 값은 무엇인가?
- 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.

뭔가를 가르쳐 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라. 만약 당신이 익숙한 애플리케이션을 구현하고 있다면, 오퍼레이션을 한두 개 필요로 하는 테스트를 하나 골라라.

### 설명 테스트

자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까? 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라.
단순한 시작법은 테스트를 이용하여 묻고, 테스트를 이용하여 설명하는 것이다.

### 학습 테스트

외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있을까? 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다.

그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다.
만약 테스트가 통과되지 않는다면 애플리케이션 역시 실행되지 않을 것이 뻔하기 때문에 애플리케이션을 실행해볼 필요도 없다. 일단 테스트가 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다.

### 또 다른 테스트

어떻게 하면 주제에 벗어나지 않고 기술적인 논의를 계속할 수 있을까? 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것.

새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다. 그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다.

### 회귀 테스트

시스템 장애가 보고될 때 여러분은 무슨 일을 제일 먼저 하는가? 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라.

회귀 테스트(regression test)란, 사실 여러분에게 완벽한 선전지명이 있다면, 처음 코딩할 때 작성했어야 하는 테스트다. 회귀 테스트를 작성할 때는 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해ㅗㅂ라.

애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다. 
좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이 된다.

### 휴식

키보드로 뭘 쳐야 할지 알면, 명백한 구현을 한다. 잘 모르겠다면 가짜 구현을 한다. 올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다.

피로해지면 올바르게 인식하기가 힘들다. 이 고리에서 빠져나가는 방법은 추가로 외부 요소를 도입하는 것이다.

- 시간 단위로는, 불명을 키보드 옆에 두어서 생리 현상으로 규칙적인 휴식을 하도록 유도한다.
- 하루 단위로는, 더 진행하기 전에 잠이 필요한 경우 정규 근무 시간 후의 약속이 진행을 일단 멈추는 데에 도움이 될 수 있다.
- 주 단위로는, 의식적이고 에너지 소모적인 업무 관련 생각을 떨쳐버리는 데에 주말 활동이 도움이 된다.
- 년 단위로는, 강제 휴가 정책이 여러분의 재충전을 완벽히 도와줄 것이다.

### 다시하기

길을 잃은 느낌이 들 땐 어떻게 할까? 코드를 다 지워버리고 처음부터 다시 해보자.

## 테스팅 패턴

이 패턴들은 더 상세한 테스트 작성법에 대한 것이다.

### 자식 테스트

지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까? 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라. 그 후 다시 원래 큰 테스트 케이스를 추가하라.

### 모의 객체

비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야할까? 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다.

전역 변수에 모의 객체로 설정 해두었다면, 테스트를 실행한 후 다시 전역 변수를 복구시켜 놓아야 한다.

모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다.
모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가된다. 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까? 모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다.

### 셀프 션트(루프백 테스트와 유사)

한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까? 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트 케이스와 대화하도록 만들면 된다.

### 로그 문자열

메세지의 호출 순서가 올바른지를 검사하려면 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다.

특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다. 만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없을 경우엔 문자열 집합을 저장하고 있다가 단언에서 집합 비교를 수행하면 된다.

### 크래시 테스트 더미

호출되지 않을 것 같은 에러 코드(발생하기 힘든 에러 상황)은 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출합니다.

작동하길 원하는 부분에 대해서만 테스트 한다.

### 깨진 테스트

혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는게 좋을까? 마지막 테스트가 깨진 상태로 끝마치는 것이 좋습니다.

프로그래밍 세션을 끝낼 때 테스트 케이스를 작성하고 이것이 실패하는 것을 확실히 확인하는 것이다. 나중에 다시 코딩하기 위해 돌아왔을때, 어느 작업부터 시작할 것인지 명백히 알 수 있다.

### 깨끗한 체크인

팀 프로그래밍할 때 프로그래밍 세션을 어떤상태로 끝마치는게 좋을까? 모든 테스트가 성공한 상태로 끝마치는 것이 좋다.
자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. 안심이 되고 확신이 있는 상태에서 시작할 필요가 있다.

## 초록 막대 패턴

코드가 테스트를 통과하게 만들기 위해 이 패턴들을 사용하라.

### 가짜로 구현하기(진짜로 만들기 전까지만)

실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는게 좋을까? 상수를 반환하게 하라.
리팩토링 단계에서 테스트 케이스와 코드 간의 데이터 중복을 제거한다.

### 삼각측량

추상화 과정을 테스트로 주도할 때 어떻게 최대한 보수적으로 할 수 있겠는가? 오로지 예가 두 개 이상일 때에만 추상화를 하라.

가짜로 구현하기를 위한 규칙들은, 추상을 끌어내기 위한 가짜구현과 테스트 케이스 사이의 중복에 대한 우리 감각에 의존하는 것으로, 약간 모호해 보이고 달리 해석될 수 있다. 삼각측량의 법칙들이 비록 단순해 보이지만 그것은 무한 루프를 만들어 낸다.

어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 정말 감잡기 어려울 때만 삼각측량을 사용한다. 그 외에 경우, 명백한 구현이나 가짜로 구현하기에 의존한다.

### 명백한 구현

단순한 연산들을 어떻게 구현하는가? 그냥 구현해 버려라.

아주 간단한게 아니라면 빨강/초록/리팩토링의 이듬을 유지하길 원한다.

### 하나에서 여럿으로

객체 컬렉션을 다루는 연산은 어떻게 구현하나? 일단은 컬렉션 없이 구현하고 그 다음에 컬렉션을 사용하게 한다.

## xUnit 패턴

### 단언(assertion)

테스트가 잘 작동하는지 어떻게 검사할 것인가? 불리언 수식을 작성해서 여러분 대신 프로그램이 자동으로 코드가 동작하는지에 대한 판단을 수행하도록 하라.

- 판단 결과가 불리언 값이어야 한다.
- 이 불러인 값이든 컴퓨터에 의해 검증되어야 한다. 보통 다양한 형태의 assert() 메서드를 호출하여 이 값을 얻어낸다.

단언은 구체적이어야 한다.

코드가 제대로 작동하는지를 판단하기 위한 용도로 변수를 사용하길 원한다면 언제나 설계를 향상할 수 있는 기회가 있다.
테스트가 변수에 의존하는 것은 현재 구현에 너무 의존적이라는 것이다. 해당 변수가 다른 타입 string -> boolean 으로 바뀌더라도 테스트가 통과할 수 있어야 한다.

### 픽스처

여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어떻게 하면 좋을까? 각 테스트 코드에 있는 지역 변수를 인스턴스 변수로 바꾸고 setup() 메서드를 재정의하여 이 메서드에서 인스턴스 변수들을 초기화하도록 한다.

객체들을 세팅하는 코드는 여러 테스트에 걸쳐 동일한 경우가 있다. 이러한 개게들은 테스트 픽스처(fixture, 정착물 혹은 고정물) 혹은 발판(scaffolding) 이라 부른다.

### 외부 픽스처

픽스처 중 외부 자원이 있을 경우 이를 어떻게 해제(release)할 것인가? tearDown() 메서드를 재정의하여 이곳에서 자원을 해재하면된다.
각 테스트의 목적 중 하나는 테스트가 실행되기 전과 식ㄹ행된 후의 외부 세계가 동일하게 유지되도록 만드는 것이다.

### 테스트 메서드

테스트 케이스 하나를 어떻게 표현할 것안가? 'test'로 시작하는 이름의 메서드로 나타내면 된다.
테스트 메서드는 의미가 그대로 드러나는 코드로, 읽기 쉬워야 한다.

### 예외 테스트

예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성할 것인가? 예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 한해서 테스트가 실패하게 만들면 된다.

예외를 던지지 않는다면 fail()을 호출하게 만들자. fail()은 테스트가 실패했음을 알려주기 위한 메서드다.
우리가 원하는 정확한 종류의 예외만을 잡아내야 한다는 점에 유의하기 바란다. 그래야만 우리가 원하는 예외가 아닌 다른 예외가 발생ㄷ한 경우 테스트가 적절히 실패할 것이기 때문이다.

### 전체 테스트

모든 테스트를 한번에 실행하려면 어떻게 해야 할까? 모든 테스트 슈트에 대한 모음을 작성하면 된다.(각각의 패키지에 대해 하나씩, 그리고 전체 애플리케이션의 패키지 테스트를 모아주는 테스트 슈트)

## 디자인 패턴

### 커맨드

계산 작업에 대한 호출(invocation of a computation)을 메시지가 아닌 객체로 표현한다.

### 값 객체

객체가 생성된 이후 그 값이 절대로 변하지 않게 하여 별칭 문제가 발생하지 않게 한다.

### 널 객체

계산 작업의 기본 사례를 객체로 표현한다.

### 템플릿 메서드

계산 작업의 변하지 않는 순서를 여러 추상 메서드로 표현한다. 이 추상 메서들은 상속을 통해 특별한 작업을 수행하게끔 구체화된다.

### 플러거블 객체

둘 이상의 구현을 객체를 호출함으로써 다양성을 표현한다.

### 플러거블 셀렉터

객체별로 서로 다른 메서드가 동적으로 호출되게 함으로써 필요 없는 하위 클래스의 생성을 피한다.

### 팩토리 메서드

생성자 대신 메서드를 호출함으로써 객체를 생성한다.

### 사칭 사기꾼(임포스터)

현존하는 프로토콜을 갖는 다른 구현을 추가하여 시스템에 변이를 도입한다.

### 컴포지트

하나의 객체로 여러 객체의 행위 조합을 표현한다.

### 수집 매개 변수

여러 다른 객체에서 계산한 결과를 모으기 위해 매개변수를 여러 곳으로 전달한다.

### 싱글톤

## 리팩토링

## TDD 마스터 하기
